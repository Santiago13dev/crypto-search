{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/kevin/Desktop/SantiagoDev/proyectospersonales/crypto-search/crypto-backend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport WebSocketFactory from './lib/websocket-factory';\nimport { CHANNEL_EVENTS, CONNECTION_STATE, DEFAULT_VERSION, DEFAULT_TIMEOUT, SOCKET_STATES, TRANSPORTS, VSN, WS_CLOSE_NORMAL } from './lib/constants';\nimport Serializer from './lib/serializer';\nimport Timer from './lib/timer';\nimport { httpEndpointURL } from './lib/transformers';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => {};\n// Connection-related constants\nconst CONNECTION_TIMEOUTS = {\n  HEARTBEAT_INTERVAL: 25000,\n  RECONNECT_DELAY: 10,\n  HEARTBEAT_TIMEOUT_FALLBACK: 100\n};\nconst RECONNECT_INTERVALS = [1000, 2000, 5000, 10000];\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nexport default class RealtimeClient {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.heartbeatCallback The optional function to handle heartbeat status.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.logLevel Sets the log level for Realtime\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n   */\n  constructor(endPoint, options) {\n    var _a;\n    this.accessTokenValue = null;\n    this.apiKey = null;\n    this.channels = new Array();\n    this.endPoint = '';\n    this.httpEndpoint = '';\n    /** @deprecated headers cannot be set on websocket connections */\n    this.headers = {};\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = null;\n    this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.heartbeatCallback = noop;\n    this.ref = 0;\n    this.reconnectTimer = null;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.accessToken = null;\n    this._connectionState = 'disconnected';\n    this._wasManualDisconnect = false;\n    this._authPromise = null;\n    /**\n     * Use either custom fetch, if provided, or default fetch to make HTTP requests\n     *\n     * @internal\n     */\n    this._resolveFetch = customFetch => {\n      let _fetch;\n      if (customFetch) {\n        _fetch = customFetch;\n      } else if (typeof fetch === 'undefined') {\n        // Node.js environment without native fetch\n        _fetch = (...args) => import('@supabase/node-fetch').then(({\n          default: fetch\n        }) => fetch(...args)).catch(error => {\n          throw new Error(`Failed to load @supabase/node-fetch: ${error.message}. ` + `This is required for HTTP requests in Node.js environments without native fetch.`);\n        });\n      } else {\n        _fetch = fetch;\n      }\n      return (...args) => _fetch(...args);\n    };\n    // Validate required parameters\n    if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\n      throw new Error('API key is required to connect to Realtime');\n    }\n    this.apiKey = options.params.apikey;\n    // Initialize endpoint URLs\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.httpEndpoint = httpEndpointURL(endPoint);\n    this._initializeOptions(options);\n    this._setupReconnectionTimer();\n    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect() {\n    // Skip if already connecting, disconnecting, or connected\n    if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {\n      return;\n    }\n    this._setConnectionState('connecting');\n    this._setAuthSafely('connect');\n    // Establish WebSocket connection\n    if (this.transport) {\n      // Use custom transport if provided\n      this.conn = new this.transport(this.endpointURL());\n    } else {\n      // Try to use native WebSocket\n      try {\n        this.conn = WebSocketFactory.createWebSocket(this.endpointURL());\n      } catch (error) {\n        this._setConnectionState('disconnected');\n        const errorMessage = error.message;\n        // Provide helpful error message based on environment\n        if (errorMessage.includes('Node.js')) {\n          throw new Error(`${errorMessage}\\n\\n` + 'To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n' + 'Option 1: Use Node.js 22+ which has native WebSocket support\\n' + 'Option 2: Install and provide the \"ws\" package:\\n\\n' + '  npm install ws\\n\\n' + '  import ws from \"ws\"\\n' + '  const client = new RealtimeClient(url, {\\n' + '    ...options,\\n' + '    transport: ws\\n' + '  })');\n        }\n        throw new Error(`WebSocket not available: ${errorMessage}`);\n      }\n    }\n    this._setupConnectionHandlers();\n  }\n  /**\n   * Returns the URL of the websocket.\n   * @returns string The URL of the websocket.\n   */\n  endpointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: VSN\n    }));\n  }\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code, reason) {\n    if (this.isDisconnecting()) {\n      return;\n    }\n    this._setConnectionState('disconnecting', true);\n    if (this.conn) {\n      // Setup fallback timer to prevent hanging in disconnecting state\n      const fallbackTimer = setTimeout(() => {\n        this._setConnectionState('disconnected');\n      }, 100);\n      this.conn.onclose = () => {\n        clearTimeout(fallbackTimer);\n        this._setConnectionState('disconnected');\n      };\n      // Close the WebSocket connection\n      if (code) {\n        this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n      } else {\n        this.conn.close();\n      }\n      this._teardownConnection();\n    } else {\n      this._setConnectionState('disconnected');\n    }\n  }\n  /**\n   * Returns all created channels\n   */\n  getChannels() {\n    return this.channels;\n  }\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  removeChannel(channel) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const status = yield channel.unsubscribe();\n      if (_this.channels.length === 0) {\n        _this.disconnect();\n      }\n      return status;\n    })();\n  }\n  /**\n   * Unsubscribes and removes all channels\n   */\n  removeAllChannels() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const values_1 = yield Promise.all(_this2.channels.map(channel => channel.unsubscribe()));\n      _this2.channels = [];\n      _this2.disconnect();\n      return values_1;\n    })();\n  }\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n  /**\n   * Returns `true` if the connection is currently connecting.\n   */\n  isConnecting() {\n    return this._connectionState === 'connecting';\n  }\n  /**\n   * Returns `true` if the connection is currently disconnecting.\n   */\n  isDisconnecting() {\n    return this._connectionState === 'disconnecting';\n  }\n  channel(topic, params = {\n    config: {}\n  }) {\n    const realtimeTopic = `realtime:${topic}`;\n    const exists = this.getChannels().find(c => c.topic === realtimeTopic);\n    if (!exists) {\n      const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n      this.channels.push(chan);\n      return chan;\n    } else {\n      return exists;\n    }\n  }\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n    const callback = () => {\n      this.encode(data, result => {\n        var _a;\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n    if (this.isConnected()) {\n      callback();\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * If param is null it will use the `accessToken` callback function or the token set on the client.\n   *\n   * On callback used, it will set the value of the token internal to the client.\n   *\n   * @param token A JWT string to override the token set on the client.\n   */\n  setAuth() {\n    var _this3 = this;\n    return _asyncToGenerator(function* (token = null) {\n      _this3._authPromise = _this3._performAuth(token);\n      try {\n        yield _this3._authPromise;\n      } finally {\n        _this3._authPromise = null;\n      }\n    }).apply(this, arguments);\n  }\n  /**\n   * Sends a heartbeat message if the socket is connected.\n   */\n  sendHeartbeat() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      if (!_this4.isConnected()) {\n        try {\n          _this4.heartbeatCallback('disconnected');\n        } catch (e) {\n          _this4.log('error', 'error in heartbeat callback', e);\n        }\n        return;\n      }\n      // Handle heartbeat timeout and force reconnection if needed\n      if (_this4.pendingHeartbeatRef) {\n        _this4.pendingHeartbeatRef = null;\n        _this4.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n        try {\n          _this4.heartbeatCallback('timeout');\n        } catch (e) {\n          _this4.log('error', 'error in heartbeat callback', e);\n        }\n        // Force reconnection after heartbeat timeout\n        _this4._wasManualDisconnect = false;\n        (_a = _this4.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'heartbeat timeout');\n        setTimeout(() => {\n          var _a;\n          if (!_this4.isConnected()) {\n            (_a = _this4.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n          }\n        }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\n        return;\n      }\n      // Send heartbeat message to server\n      _this4.pendingHeartbeatRef = _this4._makeRef();\n      _this4.push({\n        topic: 'phoenix',\n        event: 'heartbeat',\n        payload: {},\n        ref: _this4.pendingHeartbeatRef\n      });\n      try {\n        _this4.heartbeatCallback('sent');\n      } catch (e) {\n        _this4.log('error', 'error in heartbeat callback', e);\n      }\n      _this4._setAuthSafely('heartbeat');\n    })();\n  }\n  onHeartbeat(callback) {\n    this.heartbeatCallback = callback;\n  }\n  /**\n   * Flushes send buffer\n   */\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel) {\n    this.channels = this.channels.filter(c => c.topic !== channel.topic);\n  }\n  /** @internal */\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      // Handle heartbeat responses\n      if (msg.topic === 'phoenix' && msg.event === 'phx_reply') {\n        try {\n          this.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error');\n        } catch (e) {\n          this.log('error', 'error in heartbeat callback', e);\n        }\n      }\n      // Handle pending heartbeat reference cleanup\n      if (msg.ref && msg.ref === this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n      }\n      // Log incoming message\n      const {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n      const refString = ref ? `(${ref})` : '';\n      const status = payload.status || '';\n      this.log('receive', `${status} ${topic} ${event} ${refString}`.trim(), payload);\n      // Route message to appropriate channels\n      this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));\n      this._triggerStateCallbacks('message', msg);\n    });\n  }\n  /**\n   * Clear specific timer\n   * @internal\n   */\n  _clearTimer(timer) {\n    var _a;\n    if (timer === 'heartbeat' && this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = undefined;\n    } else if (timer === 'reconnect') {\n      (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\n    }\n  }\n  /**\n   * Clear all timers\n   * @internal\n   */\n  _clearAllTimers() {\n    this._clearTimer('heartbeat');\n    this._clearTimer('reconnect');\n  }\n  /**\n   * Setup connection handlers for WebSocket events\n   * @internal\n   */\n  _setupConnectionHandlers() {\n    if (!this.conn) return;\n    // Set binary type if supported (browsers and most WebSocket implementations)\n    if ('binaryType' in this.conn) {\n      ;\n      this.conn.binaryType = 'arraybuffer';\n    }\n    this.conn.onopen = () => this._onConnOpen();\n    this.conn.onerror = error => this._onConnError(error);\n    this.conn.onmessage = event => this._onConnMessage(event);\n    this.conn.onclose = event => this._onConnClose(event);\n  }\n  /**\n   * Teardown connection and cleanup resources\n   * @internal\n   */\n  _teardownConnection() {\n    if (this.conn) {\n      this.conn.onopen = null;\n      this.conn.onerror = null;\n      this.conn.onmessage = null;\n      this.conn.onclose = null;\n      this.conn = null;\n    }\n    this._clearAllTimers();\n    this.channels.forEach(channel => channel.teardown());\n  }\n  /** @internal */\n  _onConnOpen() {\n    this._setConnectionState('connected');\n    this.log('transport', `connected to ${this.endpointURL()}`);\n    this.flushSendBuffer();\n    this._clearTimer('reconnect');\n    if (!this.worker) {\n      this._startHeartbeat();\n    } else {\n      if (!this.workerRef) {\n        this._startWorkerHeartbeat();\n      }\n    }\n    this._triggerStateCallbacks('open');\n  }\n  /** @internal */\n  _startHeartbeat() {\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n  }\n  /** @internal */\n  _startWorkerHeartbeat() {\n    if (this.workerUrl) {\n      this.log('worker', `starting worker for from ${this.workerUrl}`);\n    } else {\n      this.log('worker', `starting default worker`);\n    }\n    const objectUrl = this._workerObjectUrl(this.workerUrl);\n    this.workerRef = new Worker(objectUrl);\n    this.workerRef.onerror = error => {\n      this.log('worker', 'worker error', error.message);\n      this.workerRef.terminate();\n    };\n    this.workerRef.onmessage = event => {\n      if (event.data.event === 'keepAlive') {\n        this.sendHeartbeat();\n      }\n    };\n    this.workerRef.postMessage({\n      event: 'start',\n      interval: this.heartbeatIntervalMs\n    });\n  }\n  /** @internal */\n  _onConnClose(event) {\n    var _a;\n    this._setConnectionState('disconnected');\n    this.log('transport', 'close', event);\n    this._triggerChanError();\n    this._clearTimer('heartbeat');\n    // Only schedule reconnection if it wasn't a manual disconnect\n    if (!this._wasManualDisconnect) {\n      (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n    }\n    this._triggerStateCallbacks('close', event);\n  }\n  /** @internal */\n  _onConnError(error) {\n    this._setConnectionState('disconnected');\n    this.log('transport', `${error}`);\n    this._triggerChanError();\n    this._triggerStateCallbacks('error', error);\n  }\n  /** @internal */\n  _triggerChanError() {\n    this.channels.forEach(channel => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  /** @internal */\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  _workerObjectUrl(url) {\n    let result_url;\n    if (url) {\n      result_url = url;\n    } else {\n      const blob = new Blob([WORKER_SCRIPT], {\n        type: 'application/javascript'\n      });\n      result_url = URL.createObjectURL(blob);\n    }\n    return result_url;\n  }\n  /**\n   * Set connection state with proper state management\n   * @internal\n   */\n  _setConnectionState(state, manual = false) {\n    this._connectionState = state;\n    if (state === 'connecting') {\n      this._wasManualDisconnect = false;\n    } else if (state === 'disconnecting') {\n      this._wasManualDisconnect = manual;\n    }\n  }\n  /**\n   * Perform the actual auth operation\n   * @internal\n   */\n  _performAuth() {\n    var _this5 = this;\n    return _asyncToGenerator(function* (token = null) {\n      let tokenToSend;\n      if (token) {\n        tokenToSend = token;\n      } else if (_this5.accessToken) {\n        // Always call the accessToken callback to get fresh token\n        tokenToSend = yield _this5.accessToken();\n      } else {\n        tokenToSend = _this5.accessTokenValue;\n      }\n      if (_this5.accessTokenValue != tokenToSend) {\n        _this5.accessTokenValue = tokenToSend;\n        _this5.channels.forEach(channel => {\n          const payload = {\n            access_token: tokenToSend,\n            version: DEFAULT_VERSION\n          };\n          tokenToSend && channel.updateJoinPayload(payload);\n          if (channel.joinedOnce && channel._isJoined()) {\n            channel._push(CHANNEL_EVENTS.access_token, {\n              access_token: tokenToSend\n            });\n          }\n        });\n      }\n    }).apply(this, arguments);\n  }\n  /**\n   * Wait for any in-flight auth operations to complete\n   * @internal\n   */\n  _waitForAuthIfNeeded() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (_this6._authPromise) {\n        yield _this6._authPromise;\n      }\n    })();\n  }\n  /**\n   * Safely call setAuth with standardized error handling\n   * @internal\n   */\n  _setAuthSafely(context = 'general') {\n    this.setAuth().catch(e => {\n      this.log('error', `error setting auth in ${context}`, e);\n    });\n  }\n  /**\n   * Trigger state change callbacks with proper error handling\n   * @internal\n   */\n  _triggerStateCallbacks(event, data) {\n    try {\n      this.stateChangeCallbacks[event].forEach(callback => {\n        try {\n          callback(data);\n        } catch (e) {\n          this.log('error', `error in ${event} callback`, e);\n        }\n      });\n    } catch (e) {\n      this.log('error', `error triggering ${event} callbacks`, e);\n    }\n  }\n  /**\n   * Setup reconnection timer with proper configuration\n   * @internal\n   */\n  _setupReconnectionTimer() {\n    var _this7 = this;\n    this.reconnectTimer = new Timer(/*#__PURE__*/_asyncToGenerator(function* () {\n      setTimeout(/*#__PURE__*/_asyncToGenerator(function* () {\n        yield _this7._waitForAuthIfNeeded();\n        if (!_this7.isConnected()) {\n          _this7.connect();\n        }\n      }), CONNECTION_TIMEOUTS.RECONNECT_DELAY);\n    }), this.reconnectAfterMs);\n  }\n  /**\n   * Initialize client options with defaults\n   * @internal\n   */\n  _initializeOptions(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    // Set defaults\n    this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\n    this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : DEFAULT_TIMEOUT;\n    this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n    this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\n    this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\n    this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\n    // Handle special cases\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n      this.logLevel = options.logLevel || options.log_level;\n      this.params = Object.assign(Object.assign({}, this.params), {\n        log_level: this.logLevel\n      });\n    }\n    // Set up functions with defaults\n    this.reconnectAfterMs = (_g = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _g !== void 0 ? _g : tries => {\n      return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\n    };\n    this.encode = (_h = options === null || options === void 0 ? void 0 : options.encode) !== null && _h !== void 0 ? _h : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (_j = options === null || options === void 0 ? void 0 : options.decode) !== null && _j !== void 0 ? _j : this.serializer.decode.bind(this.serializer);\n    // Handle worker setup\n    if (this.worker) {\n      if (typeof window !== 'undefined' && !window.Worker) {\n        throw new Error('Web Worker is not supported');\n      }\n      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n    }\n  }\n}","map":{"version":3,"names":["WebSocketFactory","CHANNEL_EVENTS","CONNECTION_STATE","DEFAULT_VERSION","DEFAULT_TIMEOUT","SOCKET_STATES","TRANSPORTS","VSN","WS_CLOSE_NORMAL","Serializer","Timer","httpEndpointURL","RealtimeChannel","noop","CONNECTION_TIMEOUTS","HEARTBEAT_INTERVAL","RECONNECT_DELAY","HEARTBEAT_TIMEOUT_FALLBACK","RECONNECT_INTERVALS","DEFAULT_RECONNECT_FALLBACK","WORKER_SCRIPT","RealtimeClient","constructor","endPoint","options","_a","accessTokenValue","apiKey","channels","Array","httpEndpoint","headers","params","timeout","transport","heartbeatIntervalMs","heartbeatTimer","undefined","pendingHeartbeatRef","heartbeatCallback","ref","reconnectTimer","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","accessToken","_connectionState","_wasManualDisconnect","_authPromise","_resolveFetch","customFetch","_fetch","fetch","args","then","default","catch","Error","apikey","websocket","_initializeOptions","_setupReconnectionTimer","connect","isConnecting","isDisconnecting","isConnected","_setConnectionState","_setAuthSafely","endpointURL","createWebSocket","errorMessage","includes","_setupConnectionHandlers","_appendParams","Object","assign","vsn","disconnect","code","reason","fallbackTimer","setTimeout","onclose","clearTimeout","_teardownConnection","getChannels","removeChannel","channel","_this","_asyncToGenerator","status","unsubscribe","length","removeAllChannels","_this2","values_1","Promise","all","map","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","topic","config","realtimeTopic","exists","find","c","chan","push","event","payload","callback","encode","result","send","setAuth","_this3","token","_performAuth","apply","arguments","sendHeartbeat","_this4","e","scheduleTimeout","_makeRef","onHeartbeat","flushSendBuffer","forEach","newRef","toString","_leaveOpenTopic","dupChannel","_isJoined","_isJoining","_remove","filter","_onConnMessage","rawMessage","decode","refString","trim","_isMember","_trigger","_triggerStateCallbacks","_clearTimer","timer","clearInterval","reset","_clearAllTimers","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","_onConnClose","teardown","worker","_startHeartbeat","workerRef","_startWorkerHeartbeat","setInterval","workerUrl","objectUrl","_workerObjectUrl","Worker","terminate","postMessage","interval","_triggerChanError","url","keys","prefix","match","query","URLSearchParams","result_url","blob","Blob","type","URL","createObjectURL","state","manual","_this5","tokenToSend","access_token","version","updateJoinPayload","joinedOnce","_push","_waitForAuthIfNeeded","_this6","context","_this7","reconnectAfterMs","_b","_c","_d","_e","_f","_g","_h","_j","logLevel","log_level","tries","JSON","stringify","bind","window"],"sources":["C:/Users/kevin/Desktop/SantiagoDev/proyectospersonales/crypto-search/crypto-backend/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js"],"sourcesContent":["import WebSocketFactory from './lib/websocket-factory';\nimport { CHANNEL_EVENTS, CONNECTION_STATE, DEFAULT_VERSION, DEFAULT_TIMEOUT, SOCKET_STATES, TRANSPORTS, VSN, WS_CLOSE_NORMAL, } from './lib/constants';\nimport Serializer from './lib/serializer';\nimport Timer from './lib/timer';\nimport { httpEndpointURL } from './lib/transformers';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => { };\n// Connection-related constants\nconst CONNECTION_TIMEOUTS = {\n    HEARTBEAT_INTERVAL: 25000,\n    RECONNECT_DELAY: 10,\n    HEARTBEAT_TIMEOUT_FALLBACK: 100,\n};\nconst RECONNECT_INTERVALS = [1000, 2000, 5000, 10000];\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nexport default class RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.heartbeatCallback The optional function to handle heartbeat status.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.logLevel Sets the log level for Realtime\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     */\n    constructor(endPoint, options) {\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this.channels = new Array();\n        this.endPoint = '';\n        this.httpEndpoint = '';\n        /** @deprecated headers cannot be set on websocket connections */\n        this.headers = {};\n        this.params = {};\n        this.timeout = DEFAULT_TIMEOUT;\n        this.transport = null;\n        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.heartbeatCallback = noop;\n        this.ref = 0;\n        this.reconnectTimer = null;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new Serializer();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.accessToken = null;\n        this._connectionState = 'disconnected';\n        this._wasManualDisconnect = false;\n        this._authPromise = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */\n        this._resolveFetch = (customFetch) => {\n            let _fetch;\n            if (customFetch) {\n                _fetch = customFetch;\n            }\n            else if (typeof fetch === 'undefined') {\n                // Node.js environment without native fetch\n                _fetch = (...args) => import('@supabase/node-fetch')\n                    .then(({ default: fetch }) => fetch(...args))\n                    .catch((error) => {\n                    throw new Error(`Failed to load @supabase/node-fetch: ${error.message}. ` +\n                        `This is required for HTTP requests in Node.js environments without native fetch.`);\n                });\n            }\n            else {\n                _fetch = fetch;\n            }\n            return (...args) => _fetch(...args);\n        };\n        // Validate required parameters\n        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\n            throw new Error('API key is required to connect to Realtime');\n        }\n        this.apiKey = options.params.apikey;\n        // Initialize endpoint URLs\n        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n        this.httpEndpoint = httpEndpointURL(endPoint);\n        this._initializeOptions(options);\n        this._setupReconnectionTimer();\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        // Skip if already connecting, disconnecting, or connected\n        if (this.isConnecting() ||\n            this.isDisconnecting() ||\n            (this.conn !== null && this.isConnected())) {\n            return;\n        }\n        this._setConnectionState('connecting');\n        this._setAuthSafely('connect');\n        // Establish WebSocket connection\n        if (this.transport) {\n            // Use custom transport if provided\n            this.conn = new this.transport(this.endpointURL());\n        }\n        else {\n            // Try to use native WebSocket\n            try {\n                this.conn = WebSocketFactory.createWebSocket(this.endpointURL());\n            }\n            catch (error) {\n                this._setConnectionState('disconnected');\n                const errorMessage = error.message;\n                // Provide helpful error message based on environment\n                if (errorMessage.includes('Node.js')) {\n                    throw new Error(`${errorMessage}\\n\\n` +\n                        'To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n' +\n                        'Option 1: Use Node.js 22+ which has native WebSocket support\\n' +\n                        'Option 2: Install and provide the \"ws\" package:\\n\\n' +\n                        '  npm install ws\\n\\n' +\n                        '  import ws from \"ws\"\\n' +\n                        '  const client = new RealtimeClient(url, {\\n' +\n                        '    ...options,\\n' +\n                        '    transport: ws\\n' +\n                        '  })');\n                }\n                throw new Error(`WebSocket not available: ${errorMessage}`);\n            }\n        }\n        this._setupConnectionHandlers();\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */\n    endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        if (this.isDisconnecting()) {\n            return;\n        }\n        this._setConnectionState('disconnecting', true);\n        if (this.conn) {\n            // Setup fallback timer to prevent hanging in disconnecting state\n            const fallbackTimer = setTimeout(() => {\n                this._setConnectionState('disconnected');\n            }, 100);\n            this.conn.onclose = () => {\n                clearTimeout(fallbackTimer);\n                this._setConnectionState('disconnected');\n            };\n            // Close the WebSocket connection\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n            }\n            else {\n                this.conn.close();\n            }\n            this._teardownConnection();\n        }\n        else {\n            this._setConnectionState('disconnected');\n        }\n    }\n    /**\n     * Returns all created channels\n     */\n    getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n    async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n    async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));\n        this.channels = [];\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case SOCKET_STATES.connecting:\n                return CONNECTION_STATE.Connecting;\n            case SOCKET_STATES.open:\n                return CONNECTION_STATE.Open;\n            case SOCKET_STATES.closing:\n                return CONNECTION_STATE.Closing;\n            default:\n                return CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    /**\n     * Returns `true` if the connection is currently connecting.\n     */\n    isConnecting() {\n        return this._connectionState === 'connecting';\n    }\n    /**\n     * Returns `true` if the connection is currently disconnecting.\n     */\n    isDisconnecting() {\n        return this._connectionState === 'disconnecting';\n    }\n    channel(topic, params = { config: {} }) {\n        const realtimeTopic = `realtime:${topic}`;\n        const exists = this.getChannels().find((c) => c.topic === realtimeTopic);\n        if (!exists) {\n            const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n            this.channels.push(chan);\n            return chan;\n        }\n        else {\n            return exists;\n        }\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * @param token A JWT string to override the token set on the client.\n     */\n    async setAuth(token = null) {\n        this._authPromise = this._performAuth(token);\n        try {\n            await this._authPromise;\n        }\n        finally {\n            this._authPromise = null;\n        }\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */\n    async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            try {\n                this.heartbeatCallback('disconnected');\n            }\n            catch (e) {\n                this.log('error', 'error in heartbeat callback', e);\n            }\n            return;\n        }\n        // Handle heartbeat timeout and force reconnection if needed\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            try {\n                this.heartbeatCallback('timeout');\n            }\n            catch (e) {\n                this.log('error', 'error in heartbeat callback', e);\n            }\n            // Force reconnection after heartbeat timeout\n            this._wasManualDisconnect = false;\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'heartbeat timeout');\n            setTimeout(() => {\n                var _a;\n                if (!this.isConnected()) {\n                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n                }\n            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\n            return;\n        }\n        // Send heartbeat message to server\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        try {\n            this.heartbeatCallback('sent');\n        }\n        catch (e) {\n            this.log('error', 'error in heartbeat callback', e);\n        }\n        this._setAuthSafely('heartbeat');\n    }\n    onHeartbeat(callback) {\n        this.heartbeatCallback = callback;\n    }\n    /**\n     * Flushes send buffer\n     */\n    flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n    _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n    _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n    _remove(channel) {\n        this.channels = this.channels.filter((c) => c.topic !== channel.topic);\n    }\n    /** @internal */\n    _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            // Handle heartbeat responses\n            if (msg.topic === 'phoenix' && msg.event === 'phx_reply') {\n                try {\n                    this.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error');\n                }\n                catch (e) {\n                    this.log('error', 'error in heartbeat callback', e);\n                }\n            }\n            // Handle pending heartbeat reference cleanup\n            if (msg.ref && msg.ref === this.pendingHeartbeatRef) {\n                this.pendingHeartbeatRef = null;\n            }\n            // Log incoming message\n            const { topic, event, payload, ref } = msg;\n            const refString = ref ? `(${ref})` : '';\n            const status = payload.status || '';\n            this.log('receive', `${status} ${topic} ${event} ${refString}`.trim(), payload);\n            // Route message to appropriate channels\n            this.channels\n                .filter((channel) => channel._isMember(topic))\n                .forEach((channel) => channel._trigger(event, payload, ref));\n            this._triggerStateCallbacks('message', msg);\n        });\n    }\n    /**\n     * Clear specific timer\n     * @internal\n     */\n    _clearTimer(timer) {\n        var _a;\n        if (timer === 'heartbeat' && this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = undefined;\n        }\n        else if (timer === 'reconnect') {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\n        }\n    }\n    /**\n     * Clear all timers\n     * @internal\n     */\n    _clearAllTimers() {\n        this._clearTimer('heartbeat');\n        this._clearTimer('reconnect');\n    }\n    /**\n     * Setup connection handlers for WebSocket events\n     * @internal\n     */\n    _setupConnectionHandlers() {\n        if (!this.conn)\n            return;\n        // Set binary type if supported (browsers and most WebSocket implementations)\n        if ('binaryType' in this.conn) {\n            ;\n            this.conn.binaryType = 'arraybuffer';\n        }\n        this.conn.onopen = () => this._onConnOpen();\n        this.conn.onerror = (error) => this._onConnError(error);\n        this.conn.onmessage = (event) => this._onConnMessage(event);\n        this.conn.onclose = (event) => this._onConnClose(event);\n    }\n    /**\n     * Teardown connection and cleanup resources\n     * @internal\n     */\n    _teardownConnection() {\n        if (this.conn) {\n            this.conn.onopen = null;\n            this.conn.onerror = null;\n            this.conn.onmessage = null;\n            this.conn.onclose = null;\n            this.conn = null;\n        }\n        this._clearAllTimers();\n        this.channels.forEach((channel) => channel.teardown());\n    }\n    /** @internal */\n    _onConnOpen() {\n        this._setConnectionState('connected');\n        this.log('transport', `connected to ${this.endpointURL()}`);\n        this.flushSendBuffer();\n        this._clearTimer('reconnect');\n        if (!this.worker) {\n            this._startHeartbeat();\n        }\n        else {\n            if (!this.workerRef) {\n                this._startWorkerHeartbeat();\n            }\n        }\n        this._triggerStateCallbacks('open');\n    }\n    /** @internal */\n    _startHeartbeat() {\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n    /** @internal */\n    _startWorkerHeartbeat() {\n        if (this.workerUrl) {\n            this.log('worker', `starting worker for from ${this.workerUrl}`);\n        }\n        else {\n            this.log('worker', `starting default worker`);\n        }\n        const objectUrl = this._workerObjectUrl(this.workerUrl);\n        this.workerRef = new Worker(objectUrl);\n        this.workerRef.onerror = (error) => {\n            this.log('worker', 'worker error', error.message);\n            this.workerRef.terminate();\n        };\n        this.workerRef.onmessage = (event) => {\n            if (event.data.event === 'keepAlive') {\n                this.sendHeartbeat();\n            }\n        };\n        this.workerRef.postMessage({\n            event: 'start',\n            interval: this.heartbeatIntervalMs,\n        });\n    }\n    /** @internal */\n    _onConnClose(event) {\n        var _a;\n        this._setConnectionState('disconnected');\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this._clearTimer('heartbeat');\n        // Only schedule reconnection if it wasn't a manual disconnect\n        if (!this._wasManualDisconnect) {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n        }\n        this._triggerStateCallbacks('close', event);\n    }\n    /** @internal */\n    _onConnError(error) {\n        this._setConnectionState('disconnected');\n        this.log('transport', `${error}`);\n        this._triggerChanError();\n        this._triggerStateCallbacks('error', error);\n    }\n    /** @internal */\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));\n    }\n    /** @internal */\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        }\n        else {\n            const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n    /**\n     * Set connection state with proper state management\n     * @internal\n     */\n    _setConnectionState(state, manual = false) {\n        this._connectionState = state;\n        if (state === 'connecting') {\n            this._wasManualDisconnect = false;\n        }\n        else if (state === 'disconnecting') {\n            this._wasManualDisconnect = manual;\n        }\n    }\n    /**\n     * Perform the actual auth operation\n     * @internal\n     */\n    async _performAuth(token = null) {\n        let tokenToSend;\n        if (token) {\n            tokenToSend = token;\n        }\n        else if (this.accessToken) {\n            // Always call the accessToken callback to get fresh token\n            tokenToSend = await this.accessToken();\n        }\n        else {\n            tokenToSend = this.accessTokenValue;\n        }\n        if (this.accessTokenValue != tokenToSend) {\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel) => {\n                const payload = {\n                    access_token: tokenToSend,\n                    version: DEFAULT_VERSION,\n                };\n                tokenToSend && channel.updateJoinPayload(payload);\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend,\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Wait for any in-flight auth operations to complete\n     * @internal\n     */\n    async _waitForAuthIfNeeded() {\n        if (this._authPromise) {\n            await this._authPromise;\n        }\n    }\n    /**\n     * Safely call setAuth with standardized error handling\n     * @internal\n     */\n    _setAuthSafely(context = 'general') {\n        this.setAuth().catch((e) => {\n            this.log('error', `error setting auth in ${context}`, e);\n        });\n    }\n    /**\n     * Trigger state change callbacks with proper error handling\n     * @internal\n     */\n    _triggerStateCallbacks(event, data) {\n        try {\n            this.stateChangeCallbacks[event].forEach((callback) => {\n                try {\n                    callback(data);\n                }\n                catch (e) {\n                    this.log('error', `error in ${event} callback`, e);\n                }\n            });\n        }\n        catch (e) {\n            this.log('error', `error triggering ${event} callbacks`, e);\n        }\n    }\n    /**\n     * Setup reconnection timer with proper configuration\n     * @internal\n     */\n    _setupReconnectionTimer() {\n        this.reconnectTimer = new Timer(async () => {\n            setTimeout(async () => {\n                await this._waitForAuthIfNeeded();\n                if (!this.isConnected()) {\n                    this.connect();\n                }\n            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\n        }, this.reconnectAfterMs);\n    }\n    /**\n     * Initialize client options with defaults\n     * @internal\n     */\n    _initializeOptions(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        // Set defaults\n        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\n        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs =\n            (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\n        this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\n        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\n        // Handle special cases\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n            this.logLevel = options.logLevel || options.log_level;\n            this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });\n        }\n        // Set up functions with defaults\n        this.reconnectAfterMs =\n            (_g = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _g !== void 0 ? _g : ((tries) => {\n                return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\n            });\n        this.encode =\n            (_h = options === null || options === void 0 ? void 0 : options.encode) !== null && _h !== void 0 ? _h : ((payload, callback) => {\n                return callback(JSON.stringify(payload));\n            });\n        this.decode =\n            (_j = options === null || options === void 0 ? void 0 : options.decode) !== null && _j !== void 0 ? _j : this.serializer.decode.bind(this.serializer);\n        // Handle worker setup\n        if (this.worker) {\n            if (typeof window !== 'undefined' && !window.Worker) {\n                throw new Error('Web Worker is not supported');\n            }\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}