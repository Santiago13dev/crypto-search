{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { resolveFetch } from './helper';\nimport { FunctionRegion, FunctionsFetchError, FunctionsHttpError, FunctionsRelayError } from './types';\nexport class FunctionsClient {\n  constructor(url, {\n    headers = {},\n    customFetch,\n    region = FunctionRegion.Any\n  } = {}) {\n    this.url = url;\n    this.headers = headers;\n    this.region = region;\n    this.fetch = resolveFetch(customFetch);\n  }\n  /**\n   * Updates the authorization header\n   * @param token - the new jwt token sent in the authorisation header\n   */\n  setAuth(token) {\n    this.headers.Authorization = `Bearer ${token}`;\n  }\n  /**\n   * Invokes a function\n   * @param functionName - The name of the Function to invoke.\n   * @param options - Options for invoking the Function.\n   */\n  invoke(functionName, options = {}) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          headers,\n          method,\n          body: functionArgs,\n          signal\n        } = options;\n        let _headers = {};\n        let {\n          region\n        } = options;\n        if (!region) {\n          region = this.region;\n        }\n        // Add region as query parameter using URL API\n        const url = new URL(`${this.url}/${functionName}`);\n        if (region && region !== 'any') {\n          _headers['x-region'] = region;\n          url.searchParams.set('forceFunctionRegion', region);\n        }\n        let body;\n        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type') || !headers)) {\n          if (typeof Blob !== 'undefined' && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {\n            // will work for File as File inherits Blob\n            // also works for ArrayBuffer as it is the same underlying structure as a Blob\n            _headers['Content-Type'] = 'application/octet-stream';\n            body = functionArgs;\n          } else if (typeof functionArgs === 'string') {\n            // plain string\n            _headers['Content-Type'] = 'text/plain';\n            body = functionArgs;\n          } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {\n            // don't set content-type headers\n            // Request will automatically add the right boundary value\n            body = functionArgs;\n          } else {\n            // default, assume this is JSON\n            _headers['Content-Type'] = 'application/json';\n            body = JSON.stringify(functionArgs);\n          }\n        }\n        const response = yield this.fetch(url.toString(), {\n          method: method || 'POST',\n          // headers priority is (high to low):\n          // 1. invoke-level headers\n          // 2. client-level headers\n          // 3. default Content-Type header\n          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n          body,\n          signal\n        }).catch(fetchError => {\n          if (fetchError.name === 'AbortError') {\n            throw fetchError;\n          }\n          throw new FunctionsFetchError(fetchError);\n        });\n        const isRelayError = response.headers.get('x-relay-error');\n        if (isRelayError && isRelayError === 'true') {\n          throw new FunctionsRelayError(response);\n        }\n        if (!response.ok) {\n          throw new FunctionsHttpError(response);\n        }\n        let responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();\n        let data;\n        if (responseType === 'application/json') {\n          data = yield response.json();\n        } else if (responseType === 'application/octet-stream') {\n          data = yield response.blob();\n        } else if (responseType === 'text/event-stream') {\n          data = response;\n        } else if (responseType === 'multipart/form-data') {\n          data = yield response.formData();\n        } else {\n          // default to text\n          data = yield response.text();\n        }\n        return {\n          data,\n          error: null,\n          response\n        };\n      } catch (error) {\n        if (error instanceof Error && error.name === 'AbortError') {\n          return {\n            data: null,\n            error: new FunctionsFetchError(error)\n          };\n        }\n        return {\n          data: null,\n          error,\n          response: error instanceof FunctionsHttpError || error instanceof FunctionsRelayError ? error.context : undefined\n        };\n      }\n    });\n  }\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","resolveFetch","FunctionRegion","FunctionsFetchError","FunctionsHttpError","FunctionsRelayError","FunctionsClient","constructor","url","headers","customFetch","region","Any","fetch","setAuth","token","Authorization","invoke","functionName","options","_a","method","body","functionArgs","signal","_headers","URL","searchParams","set","Object","prototype","hasOwnProperty","call","Blob","ArrayBuffer","FormData","JSON","stringify","response","toString","assign","catch","fetchError","name","isRelayError","get","ok","responseType","split","trim","data","json","blob","formData","text","error","Error","context","undefined"],"sources":["C:/Users/kevin/Desktop/SantiagoDev/proyectospersonales/crypto-search/crypto-backend/node_modules/@supabase/functions-js/dist/module/FunctionsClient.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { resolveFetch } from './helper';\nimport { FunctionRegion, FunctionsFetchError, FunctionsHttpError, FunctionsRelayError, } from './types';\nexport class FunctionsClient {\n    constructor(url, { headers = {}, customFetch, region = FunctionRegion.Any, } = {}) {\n        this.url = url;\n        this.headers = headers;\n        this.region = region;\n        this.fetch = resolveFetch(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @param token - the new jwt token sent in the authorisation header\n     */\n    setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - The name of the Function to invoke.\n     * @param options - Options for invoking the Function.\n     */\n    invoke(functionName, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { headers, method, body: functionArgs, signal } = options;\n                let _headers = {};\n                let { region } = options;\n                if (!region) {\n                    region = this.region;\n                }\n                // Add region as query parameter using URL API\n                const url = new URL(`${this.url}/${functionName}`);\n                if (region && region !== 'any') {\n                    _headers['x-region'] = region;\n                    url.searchParams.set('forceFunctionRegion', region);\n                }\n                let body;\n                if (functionArgs &&\n                    ((headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type')) || !headers)) {\n                    if ((typeof Blob !== 'undefined' && functionArgs instanceof Blob) ||\n                        functionArgs instanceof ArrayBuffer) {\n                        // will work for File as File inherits Blob\n                        // also works for ArrayBuffer as it is the same underlying structure as a Blob\n                        _headers['Content-Type'] = 'application/octet-stream';\n                        body = functionArgs;\n                    }\n                    else if (typeof functionArgs === 'string') {\n                        // plain string\n                        _headers['Content-Type'] = 'text/plain';\n                        body = functionArgs;\n                    }\n                    else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {\n                        // don't set content-type headers\n                        // Request will automatically add the right boundary value\n                        body = functionArgs;\n                    }\n                    else {\n                        // default, assume this is JSON\n                        _headers['Content-Type'] = 'application/json';\n                        body = JSON.stringify(functionArgs);\n                    }\n                }\n                const response = yield this.fetch(url.toString(), {\n                    method: method || 'POST',\n                    // headers priority is (high to low):\n                    // 1. invoke-level headers\n                    // 2. client-level headers\n                    // 3. default Content-Type header\n                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n                    body,\n                    signal,\n                }).catch((fetchError) => {\n                    if (fetchError.name === 'AbortError') {\n                        throw fetchError;\n                    }\n                    throw new FunctionsFetchError(fetchError);\n                });\n                const isRelayError = response.headers.get('x-relay-error');\n                if (isRelayError && isRelayError === 'true') {\n                    throw new FunctionsRelayError(response);\n                }\n                if (!response.ok) {\n                    throw new FunctionsHttpError(response);\n                }\n                let responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();\n                let data;\n                if (responseType === 'application/json') {\n                    data = yield response.json();\n                }\n                else if (responseType === 'application/octet-stream') {\n                    data = yield response.blob();\n                }\n                else if (responseType === 'text/event-stream') {\n                    data = response;\n                }\n                else if (responseType === 'multipart/form-data') {\n                    data = yield response.formData();\n                }\n                else {\n                    // default to text\n                    data = yield response.text();\n                }\n                return { data, error: null, response };\n            }\n            catch (error) {\n                if (error instanceof Error && error.name === 'AbortError') {\n                    return { data: null, error: new FunctionsFetchError(error) };\n                }\n                return {\n                    data: null,\n                    error,\n                    response: error instanceof FunctionsHttpError || error instanceof FunctionsRelayError\n                        ? error.context\n                        : undefined,\n                };\n            }\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}