{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/kevin/Desktop/SantiagoDev/proyectospersonales/crypto-search/crypto-backend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CHANNEL_EVENTS, CHANNEL_STATES, MAX_PUSH_BUFFER_SIZE } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nimport { httpEndpointURL } from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n  REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n  REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n  REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n  REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n  constructor(/** Topic name can be any string. */\n  topic, params = {\n    config: {}\n  }, socket) {\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.subTopic = topic.replace(/^realtime:/i, '');\n    this.params.config = Object.assign({\n      broadcast: {\n        ack: false,\n        self: false\n      },\n      presence: {\n        key: '',\n        enabled: false\n      },\n      private: false\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this._onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket._remove(this);\n    });\n    this._onError(reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return;\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('error', reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this._trigger(this._replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);\n    this.private = this.params.config.private || false;\n  }\n  /** Subscribe registers your client with the server */\n  subscribe(callback, timeout = this.timeout) {\n    var _this = this;\n    var _a, _b, _c;\n    if (!this.socket.isConnected()) {\n      this.socket.connect();\n    }\n    if (this.state == CHANNEL_STATES.closed) {\n      const {\n        config: {\n          broadcast,\n          presence,\n          private: isPrivate\n        }\n      } = this.params;\n      const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : [];\n      const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n      const accessTokenPayload = {};\n      const config = {\n        broadcast,\n        presence: Object.assign(Object.assign({}, presence), {\n          enabled: presence_enabled\n        }),\n        postgres_changes,\n        private: isPrivate\n      };\n      if (this.socket.accessTokenValue) {\n        accessTokenPayload.access_token = this.socket.accessTokenValue;\n      }\n      this._onError(e => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n      this.updateJoinPayload(Object.assign({\n        config\n      }, accessTokenPayload));\n      this.joinedOnce = true;\n      this._rejoin(timeout);\n      this.joinPush.receive('ok', /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* ({\n          postgres_changes\n        }) {\n          var _a;\n          _this.socket.setAuth();\n          if (postgres_changes === undefined) {\n            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n            return;\n          } else {\n            const clientPostgresBindings = _this.bindings.postgres_changes;\n            const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n            const newPostgresBindings = [];\n            for (let i = 0; i < bindingsLen; i++) {\n              const clientPostgresBinding = clientPostgresBindings[i];\n              const {\n                filter: {\n                  event,\n                  schema,\n                  table,\n                  filter\n                }\n              } = clientPostgresBinding;\n              const serverPostgresFilter = postgres_changes && postgres_changes[i];\n              if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n                newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                  id: serverPostgresFilter.id\n                }));\n              } else {\n                _this.unsubscribe();\n                _this.state = CHANNEL_STATES.errored;\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\n                return;\n              }\n            }\n            _this.bindings.postgres_changes = newPostgresBindings;\n            callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n            return;\n          }\n        });\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }()).receive('error', error => {\n        this.state = CHANNEL_STATES.errored;\n        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n        return;\n      }).receive('timeout', () => {\n        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n        return;\n      });\n    }\n    return this;\n  }\n  presenceState() {\n    return this.presence.state;\n  }\n  track(_x2) {\n    var _this2 = this;\n    return _asyncToGenerator(function* (payload, opts = {}) {\n      return yield _this2.send({\n        type: 'presence',\n        event: 'track',\n        payload\n      }, opts.timeout || _this2.timeout);\n    }).apply(this, arguments);\n  }\n  untrack() {\n    var _this3 = this;\n    return _asyncToGenerator(function* (opts = {}) {\n      return yield _this3.send({\n        type: 'presence',\n        event: 'untrack'\n      }, opts);\n    }).apply(this, arguments);\n  }\n  on(type, filter, callback) {\n    if (this.state === CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\n      this.socket.log('channel', `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\n      this.unsubscribe().then(() => this.subscribe());\n    }\n    return this._on(type, filter, callback);\n  }\n  /**\n   * Sends a message into the channel.\n   *\n   * @param args Arguments to send to channel\n   * @param args.type The type of event to send\n   * @param args.event The name of the event being sent\n   * @param args.payload Payload to be sent\n   * @param opts Options to be used during the send process\n   */\n  send(_x3) {\n    var _this4 = this;\n    return _asyncToGenerator(function* (args, opts = {}) {\n      var _a, _b;\n      if (!_this4._canPush() && args.type === 'broadcast') {\n        const {\n          event,\n          payload: endpoint_payload\n        } = args;\n        const authorization = _this4.socket.accessTokenValue ? `Bearer ${_this4.socket.accessTokenValue}` : '';\n        const options = {\n          method: 'POST',\n          headers: {\n            Authorization: authorization,\n            apikey: _this4.socket.apiKey ? _this4.socket.apiKey : '',\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            messages: [{\n              topic: _this4.subTopic,\n              event,\n              payload: endpoint_payload,\n              private: _this4.private\n            }]\n          })\n        };\n        try {\n          const response = yield _this4._fetchWithTimeout(_this4.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : _this4.timeout);\n          yield (_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel();\n          return response.ok ? 'ok' : 'error';\n        } catch (error) {\n          if (error.name === 'AbortError') {\n            return 'timed out';\n          } else {\n            return 'error';\n          }\n        }\n      } else {\n        return new Promise(resolve => {\n          var _a, _b, _c;\n          const push = _this4._push(args.type, args, opts.timeout || _this4.timeout);\n          if (args.type === 'broadcast' && !((_c = (_b = (_a = _this4.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n            resolve('ok');\n          }\n          push.receive('ok', () => resolve('ok'));\n          push.receive('error', () => resolve('error'));\n          push.receive('timeout', () => resolve('timed out'));\n        });\n      }\n    }).apply(this, arguments);\n  }\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving;\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n    };\n    this.joinPush.destroy();\n    let leavePush = null;\n    return new Promise(resolve => {\n      leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', () => {\n        onClose();\n        resolve('ok');\n      }).receive('timeout', () => {\n        onClose();\n        resolve('timed out');\n      }).receive('error', () => {\n        resolve('error');\n      });\n      leavePush.send();\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {});\n      }\n    }).finally(() => {\n      leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n    });\n  }\n  /**\n   * Teardown the channel.\n   *\n   * Destroys and stops related timers.\n   */\n  teardown() {\n    this.pushBuffer.forEach(push => push.destroy());\n    this.pushBuffer = [];\n    this.rejoinTimer.reset();\n    this.joinPush.destroy();\n    this.state = CHANNEL_STATES.closed;\n    this.bindings = {};\n  }\n  /** @internal */\n  _fetchWithTimeout(url, options, timeout) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const controller = new AbortController();\n      const id = setTimeout(() => controller.abort(), timeout);\n      const response = yield _this5.socket.fetch(url, Object.assign(Object.assign({}, options), {\n        signal: controller.signal\n      }));\n      clearTimeout(id);\n      return response;\n    })();\n  }\n  /** @internal */\n  _push(event, payload, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n    let pushEvent = new Push(this, event, payload, timeout);\n    if (this._canPush()) {\n      pushEvent.send();\n    } else {\n      this._addToPushBuffer(pushEvent);\n    }\n    return pushEvent;\n  }\n  /** @internal */\n  _addToPushBuffer(pushEvent) {\n    pushEvent.startTimeout();\n    this.pushBuffer.push(pushEvent);\n    // Enforce buffer size limit\n    if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {\n      const removedPush = this.pushBuffer.shift();\n      if (removedPush) {\n        removedPush.destroy();\n        this.socket.log('channel', `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\n      }\n    }\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n  _onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  /** @internal */\n  _isMember(topic) {\n    return this.topic === topic;\n  }\n  /** @internal */\n  _joinRef() {\n    return this.joinPush.ref;\n  }\n  /** @internal */\n  _trigger(type, payload, ref) {\n    var _a, _b;\n    const typeLower = type.toLocaleLowerCase();\n    const {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return;\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref);\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(bind => {\n        var _a, _b, _c;\n        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n      }).map(bind => bind.callback(handledPayload, ref));\n    } else {\n      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(bind => {\n        var _a, _b, _c, _d, _e, _f;\n        if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n          if ('id' in bind) {\n            const bindId = bind.id;\n            const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n            return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n          } else {\n            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n            return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n          }\n        } else {\n          return bind.type.toLocaleLowerCase() === typeLower;\n        }\n      }).map(bind => {\n        if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n          const postgresChanges = handledPayload.data;\n          const {\n            schema,\n            table,\n            commit_timestamp,\n            type,\n            errors\n          } = postgresChanges;\n          const enrichedPayload = {\n            schema: schema,\n            table: table,\n            commit_timestamp: commit_timestamp,\n            eventType: type,\n            new: {},\n            old: {},\n            errors: errors\n          };\n          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n        }\n        bind.callback(handledPayload, ref);\n      });\n    }\n  }\n  /** @internal */\n  _isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /** @internal */\n  _isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /** @internal */\n  _isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /** @internal */\n  _isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  /** @internal */\n  _replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  /** @internal */\n  _on(type, filter, callback) {\n    const typeLower = type.toLocaleLowerCase();\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback\n    };\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding);\n    } else {\n      this.bindings[typeLower] = [binding];\n    }\n    return this;\n  }\n  /** @internal */\n  _off(type, filter) {\n    const typeLower = type.toLocaleLowerCase();\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {\n        var _a;\n        return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n      });\n    }\n    return this;\n  }\n  /** @internal */\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /** @internal */\n  _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n    if (this.socket.isConnected()) {\n      this._rejoin();\n    }\n  }\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n  _onClose(callback) {\n    this._on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n  _onError(callback) {\n    this._on(CHANNEL_EVENTS.error, {}, reason => callback(reason));\n  }\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n  _canPush() {\n    return this.socket.isConnected() && this._isJoined();\n  }\n  /** @internal */\n  _rejoin(timeout = this.timeout) {\n    if (this._isLeaving()) {\n      return;\n    }\n    this.socket._leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /** @internal */\n  _getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record);\n    }\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n    }\n    return records;\n  }\n}","map":{"version":3,"names":["CHANNEL_EVENTS","CHANNEL_STATES","MAX_PUSH_BUFFER_SIZE","Push","Timer","RealtimePresence","Transformers","httpEndpointURL","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","REALTIME_CHANNEL_STATES","RealtimeChannel","constructor","topic","params","config","socket","bindings","state","closed","joinedOnce","pushBuffer","subTopic","replace","Object","assign","broadcast","ack","self","presence","key","enabled","private","timeout","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","receive","joined","reset","forEach","pushEvent","send","_onClose","log","_joinRef","_remove","_onError","reason","_isLeaving","_isClosed","errored","scheduleTimeout","_isJoining","_on","reply","payload","ref","_trigger","_replyEventName","broadcastEndpointURL","endPoint","subscribe","callback","_this","_a","_b","_c","isConnected","connect","isPrivate","postgres_changes","map","r","filter","presence_enabled","PRESENCE","length","accessTokenPayload","accessTokenValue","access_token","e","CHANNEL_ERROR","CLOSED","updateJoinPayload","_rejoin","_ref2","_asyncToGenerator","setAuth","undefined","SUBSCRIBED","clientPostgresBindings","bindingsLen","newPostgresBindings","i","clientPostgresBinding","event","schema","table","serverPostgresFilter","push","id","unsubscribe","Error","_x","apply","arguments","error","JSON","stringify","values","TIMED_OUT","presenceState","track","_x2","_this2","opts","type","untrack","_this3","on","then","_x3","_this4","args","_canPush","endpoint_payload","authorization","options","method","headers","Authorization","apikey","apiKey","body","messages","response","_fetchWithTimeout","cancel","ok","name","Promise","resolve","_push","updatePayload","leaving","onClose","close","destroy","leavePush","leave","trigger","finally","teardown","url","_this5","controller","AbortController","setTimeout","abort","fetch","signal","clearTimeout","_addToPushBuffer","startTimeout","removedPush","shift","_onMessage","_event","_ref","_isMember","typeLower","toLocaleLowerCase","events","indexOf","handledPayload","includes","bind","_d","_e","_f","bindId","bindEvent","ids","data","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","_off","isEqual","obj1","obj2","keys","k","_leaveOpenTopic","resend","records","convertChangeData","columns","record","old_record"],"sources":["C:/Users/kevin/Desktop/SantiagoDev/proyectospersonales/crypto-search/crypto-backend/node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES, MAX_PUSH_BUFFER_SIZE, } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nimport { httpEndpointURL } from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n    constructor(\n    /** Topic name can be any string. */\n    topic, params = { config: {} }, socket) {\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, '');\n        this.params.config = Object.assign({\n            broadcast: { ack: false, self: false },\n            presence: { key: '', enabled: false },\n            private: false,\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n            this.state = CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('error', (reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new RealtimePresence(this);\n        this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);\n        this.private = this.params.config.private || false;\n    }\n    /** Subscribe registers your client with the server */\n    subscribe(callback, timeout = this.timeout) {\n        var _a, _b, _c;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.state == CHANNEL_STATES.closed) {\n            const { config: { broadcast, presence, private: isPrivate }, } = this.params;\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [];\n            const presence_enabled = (!!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] &&\n                this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0) ||\n                ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),\n                postgres_changes,\n                private: isPrivate,\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush\n                .receive('ok', async ({ postgres_changes }) => {\n                var _a;\n                this.socket.setAuth();\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n                else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for (let i = 0; i < bindingsLen; i++) {\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter &&\n                            serverPostgresFilter.event === event &&\n                            serverPostgresFilter.schema === schema &&\n                            serverPostgresFilter.table === table &&\n                            serverPostgresFilter.filter === filter) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\n                        }\n                        else {\n                            this.unsubscribe();\n                            this.state = CHANNEL_STATES.errored;\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            })\n                .receive('error', (error) => {\n                this.state = CHANNEL_STATES.errored;\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n                return;\n            })\n                .receive('timeout', () => {\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    presenceState() {\n        return this.presence.state;\n    }\n    async track(payload, opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'track',\n            payload,\n        }, opts.timeout || this.timeout);\n    }\n    async untrack(opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'untrack',\n        }, opts);\n    }\n    on(type, filter, callback) {\n        if (this.state === CHANNEL_STATES.joined &&\n            type === REALTIME_LISTEN_TYPES.PRESENCE) {\n            this.socket.log('channel', `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\n            this.unsubscribe().then(() => this.subscribe());\n        }\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */\n    async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === 'broadcast') {\n            const { event, payload: endpoint_payload } = args;\n            const authorization = this.socket.accessTokenValue\n                ? `Bearer ${this.socket.accessTokenValue}`\n                : '';\n            const options = {\n                method: 'POST',\n                headers: {\n                    Authorization: authorization,\n                    apikey: this.socket.apiKey ? this.socket.apiKey : '',\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private,\n                        },\n                    ],\n                }),\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? 'ok' : 'error';\n            }\n            catch (error) {\n                if (error.name === 'AbortError') {\n                    return 'timed out';\n                }\n                else {\n                    return 'error';\n                }\n            }\n        }\n        else {\n            return new Promise((resolve) => {\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve('ok');\n                }\n                push.receive('ok', () => resolve('ok'));\n                push.receive('error', () => resolve('error'));\n                push.receive('timeout', () => resolve('timed out'));\n            });\n        }\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = CHANNEL_STATES.leaving;\n        const onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n        };\n        this.joinPush.destroy();\n        let leavePush = null;\n        return new Promise((resolve) => {\n            leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush\n                .receive('ok', () => {\n                onClose();\n                resolve('ok');\n            })\n                .receive('timeout', () => {\n                onClose();\n                resolve('timed out');\n            })\n                .receive('error', () => {\n                resolve('error');\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger('ok', {});\n            }\n        }).finally(() => {\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n        });\n    }\n    /**\n     * Teardown the channel.\n     *\n     * Destroys and stops related timers.\n     */\n    teardown() {\n        this.pushBuffer.forEach((push) => push.destroy());\n        this.pushBuffer = [];\n        this.rejoinTimer.reset();\n        this.joinPush.destroy();\n        this.state = CHANNEL_STATES.closed;\n        this.bindings = {};\n    }\n    /** @internal */\n    async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(() => controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */\n    _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new Push(this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        }\n        else {\n            this._addToPushBuffer(pushEvent);\n        }\n        return pushEvent;\n    }\n    /** @internal */\n    _addToPushBuffer(pushEvent) {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n        // Enforce buffer size limit\n        if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {\n            const removedPush = this.pushBuffer.shift();\n            if (removedPush) {\n                removedPush.destroy();\n                this.socket.log('channel', `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\n            }\n        }\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */\n    _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */\n    _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */\n    _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */\n    _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = CHANNEL_EVENTS;\n        const events = [close, error, leave, join];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\n                var _a, _b, _c;\n                return (((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' ||\n                    ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower);\n            }).map((bind) => bind.callback(handledPayload, ref));\n        }\n        else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\n                var _a, _b, _c, _d, _e, _f;\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n                    if ('id' in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return (bindId &&\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\n                            (bindEvent === '*' ||\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) ===\n                                    ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\n                    }\n                    else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return (bindEvent === '*' ||\n                            bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase()));\n                    }\n                }\n                else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind) => {\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors,\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */\n    _isClosed() {\n        return this.state === CHANNEL_STATES.closed;\n    }\n    /** @internal */\n    _isJoined() {\n        return this.state === CHANNEL_STATES.joined;\n    }\n    /** @internal */\n    _isJoining() {\n        return this.state === CHANNEL_STATES.joining;\n    }\n    /** @internal */\n    _isLeaving() {\n        return this.state === CHANNEL_STATES.leaving;\n    }\n    /** @internal */\n    _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */\n    _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback,\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        }\n        else {\n            this.bindings[typeLower] = [binding];\n        }\n        return this;\n    }\n    /** @internal */\n    _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n                var _a;\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\n                    RealtimeChannel.isEqual(bind.filter, filter));\n            });\n        }\n        return this;\n    }\n    /** @internal */\n    static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (const k in obj1) {\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */\n    _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */\n    _onClose(callback) {\n        this._on(CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */\n    _onError(callback) {\n        this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */\n    _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */\n    _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */\n    _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {},\n        };\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}